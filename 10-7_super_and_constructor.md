# 10-7. super()와 super 키워드의 동작 (Constructor & Member Access)

## 1) 생성자 호출에서의 super()

자식 클래스의 생성자는 실행되기 전에 **부모 클래스의 생성자를 반드시 호출**해야 한다.  
컴파일러는 이를 보장하기 위해 **모든 자식 생성자의 첫 줄에 `super()`를 자동 삽입**한다.

### 예시
```java
class A {
    A() {
        System.out.println("A 생성자");
    }
}

class B extends A {
    B() {
        super(); // 생략 시 컴파일러가 자동 추가됨
        System.out.println("B 생성자");
    }
}
```
**실행 순서**
```
A 생성자
B 생성자
```

> 즉, 자식 객체를 생성하면 부모 생성자가 먼저 호출된 후, 자식 생성자가 실행된다.

---

## 2) 매개변수 있는 부모 생성자의 경우

부모 클래스에 **기본 생성자(C())가 존재하지 않는 경우**,  
자동 추가되는 `super()` 는 사용할 수 없다 → **컴파일 오류** 발생.

```java
class C {
    C(int a) {
        System.out.println("C 생성자");
    }
}

class D extends C {
    /* 컴파일러가 자동 추가하는 내용 (하지만 부모에 기본 생성자가 없으므로 오류 발생)
    D() {
        super(); // ❌ C()가 존재하지 않음
    }
    */

    D() {
        super(3); // ✅ 부모의 C(int a) 생성자를 직접 호출
    }
}
```
- `super(3)` : 부모 클래스의 **생성자 중 int 매개변수를 가지는 생성자**를 명시적으로 호출.
- 부모에 기본 생성자가 없을 경우 반드시 이렇게 **명시적 super(값)** 을 작성해야 함.

---

## 3) 멤버 접근에서의 super 키워드

`super`는 생성자 호출뿐만 아니라, **부모 클래스의 멤버(필드나 메서드)** 에 접근할 때도 사용 가능하다.

```java
class Parent {
    void show() { System.out.println("부모의 show()"); }
}

class Child extends Parent {
    void show() {
        super.show(); // 부모의 show()를 명시적으로 호출
        System.out.println("자식의 show()");
    }
}
```
**실행 결과**
```
부모의 show()
자식의 show()
```

> **`super.멤버`** 를 사용하면 자신의 클래스 내부 검색을 건너뛰고 **부모 클래스 내부의 멤버를 바로 참조**한다.

---

## ✅ 핵심 요약

| 구분 | 기능 | 자동 추가 여부 |
|---|---|---|
| `super()` | 부모 생성자 호출 | ✅ 기본 생성자 있는 경우 자동 추가 |
| `super(값)` | 부모의 특정 매개변수 생성자 호출 | ❌ 직접 명시 필요 |
| `super.멤버` | 부모 클래스의 필드나 메서드 접근 | ❌ 직접 명시 필요 |

> **정리:**  
> - 생성자에서 `super()`는 부모 초기화를 위해 자동 추가됨.  
> - 부모에 기본 생성자가 없을 때는 `super(값)`을 명시해야 함.  
> - `super.멤버`는 자신의 클래스 멤버 검색을 건너뛰고 부모 멤버를 직접 참조한다.
